import java.util.concurrent.atomic.AtomicBoolean

plugins {
    id 'java'
    id 'com.gradle.build-scan' version '2.2'
}

group 'org.gradle'
version '1.0-SNAPSHOT'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    implementation project(':cache-examples-lib')
    testImplementation 'junit:junit:4.12'
}

ext.geServer = System.getProperty('geServer')

buildScan {
    publishAlways()

    if (geServer != null) {
        // Use private server
        server = geServer
        captureTaskInputFiles = true

        background {
            def gitCommitId = execAndGetStdout('git', 'rev-parse', '--verify', 'HEAD')
            def branchName = execAndGetStdout('git', 'rev-parse', '--abbrev-ref', 'HEAD')
            def status = execAndGetStdout('git', 'status', '--porcelain')
            if (branchName != null && !branchName.isEmpty() && branchName != 'HEAD') {
                tag branchName
                value 'Git branch name', branchName
            }
            if (status != null && !status.isEmpty()) {
                tag 'dirty'
                value 'Git status', status
            }
            value 'Git Commit ID', gitCommitId
            link 'Git commit scans', customValueSearchUrl(['Git Commit ID': gitCommitId])
        }

//        if (System.getenv('CI')) {
//            tag 'CI'
//        } else {
//            tag 'LOCAL'
//        }
    } else {
        // Use public scans server
        termsOfServiceUrl = 'https://gradle.com/terms-of-service'
        termsOfServiceAgree = 'yes'
    }
}

gradle.taskGraph.afterTask { task ->
    if (isBuildCacheEnabled() && isCacheMiss(task) && isNotTaggedYet()) {
        buildScan.tag 'CACHE_MISS'
    }
}

def isBuildCacheEnabled() {
    gradle.startParameter.buildCacheEnabled
}

ext.cacheMissTagged = new AtomicBoolean(false)
def isNotTaggedYet() {
    cacheMissTagged.compareAndSet(false, true)
}

static isCacheMiss(Task task) {
    !task.state.skipped && isCompileCacheMiss(task)
}

static isCompileCacheMiss(Task task) {
    isMonitoredCompileTask(task) && !isExpectedCompileCacheMiss(task)
}

static isMonitoredCompileTask(Task task) {
    task instanceof AbstractCompile
}

static isExpectedCompileCacheMiss(Task task) {
    // Simplification for demo purposes
    false
}

def customValueSearchUrl(Map<String, String> search) {
    def query = search.collect { name, value ->
        "search.names=${URLEncoder.encode(name, 'UTF-8')}&search.values=${URLEncoder.encode(value, 'UTF-8')}"
    }.join('&')
    "$geServer/scans?$query${withComparison()}"
}

static withComparison() {
    "#selection.buildScanA=${URLEncoder.encode('{SCAN_ID}', 'UTF-8')}"
}

def execAndGetStdout(String... args) {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine(args)
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

def createSourceTask = tasks.register('createSource', CreateSourceTask) {
    outputFile = file("$buildDir/$name/src/main/java/GeneratedClass.java")
    configFile = file("src/config/config.properties")

    if (project.hasProperty('stable')) {
        // A Tuesday
        timestamp = 1551224060480L
        stable = true
    }
}

sourceSets {
    main {
        java.srcDirs += "${buildDir}/$createSourceTask.name/src/main/java/"
    }
}

tasks.named('compileJava').configure {
    dependsOn createSourceTask
}

tasks.register("unrelocatableTask", UnrelocatableTask) {
    outputFile = file("$buildDir/$name/out_file")
    configFile = file("src/config/config.properties")
}

def buildInfoTask = tasks.register("writeBuildInfo") {
    doLast {
        def buildInfo = file("src/main/resources/build-info.properties")
        buildInfo.delete()
        buildInfo << "timestamp=${System.currentTimeMillis()}\n"
        buildInfo << "user=${System.getenv("USER")}"
    }
}
check.dependsOn buildInfoTask

normalization {
    runtimeClasspath {
        if (project.hasProperty('stable')) {
            ignore 'build-info.properties'
        }
    }
}

@CacheableTask
class CreateSourceTask extends DefaultTask {

    private File _outputFile
    private File _configFile
    private long _timestamp = System.currentTimeMillis()
    private boolean _stable = false

    void setOutputFile(File outputFile) {
        _outputFile = outputFile
    }

    @OutputFile
    File getOutputFile() {
        return _outputFile
    }

    void setTimestamp(long timestamp) {
        _timestamp = timestamp
    }

    @Input
    long getTimestamp() {
        return _timestamp
    }

    void setConfigFile(File configFile) {
        _configFile = configFile
    }

    @PathSensitive(PathSensitivity.NONE)
    @InputFile
    File getConfigFile() {
        return _configFile
    }

    void setStable(boolean stable) {
        _stable = stable
    }

    @Internal
    boolean isStable() {
        return _stable
    }

    @TaskAction
    def action() {
        outputFile.delete()

        def path
        if (stable) {
            path = project.projectDir.relativePath(configFile)
        } else {
            path = configFile.absolutePath
        }

        outputFile << """
// Path to config file: $path
class GeneratedClass {

    public long currentTime = ${timestamp}L;

    void sayHello() {
        System.out.println("Hello, world! It is now " + currentTime);
    }
}
"""
    }
}

@CacheableTask
class UnrelocatableTask extends DefaultTask {

    private File _outputFile
    private File _configFile

    void setOutputFile(File outputFile) {
        _outputFile = outputFile
    }

    @OutputFile
    File getOutputFile() {
        return _outputFile
    }

    void setConfigFile(File configFile) {
        _configFile = configFile
    }

//    @PathSensitive(PathSensitivity.NONE)
    @InputFile
    File getConfigFile() {
        return _configFile
    }

    @TaskAction
    def action() {
        outputFile.delete()
        outputFile << configFile.text
    }
}
